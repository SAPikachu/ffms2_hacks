<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>
FFmpegSource2 API Documentation
</title>
<link href="style.css" media="screen" rel="Stylesheet" type="text/css" />
</head>
<body>
<div class="maincontent">
<h1>FFmpegSource2 API Documentation</h1>
<p>
FFmpegSource2 (FFMS2) is a wrapper library around ffmpeg, plus some additional components to deal with file formats libavformat has (or used to have) problems with. It gives you a convenient way to say "open and decompress this media file for me, I don't care how you do it", without having to bother with the sometimes less than straightforward and less than perfectly documented ffmpeg internals. May be frame and/or sample accurate on good days. The library is written in C++, but the public API is C-friendly and it should be possible to simply include and link directly with a pure C application.</p>

<p>The source is MIT licensed and can be obtained from the Google Code project SVN; see <a href="http://code.google.com/p/ffmpegsource/source/checkout">http://code.google.com/p/ffmpegsource/source/checkout</a>.
</p>


<h2>Limitations</h2>
<p>
FFMS2 does not mux or encode anything. FFMS2 does not give you fine control over codec internals. FFMS2 does not let you demux raw compressed data, you get it decompressed or not at all. FFMS2 does not provide you with a good solution for realtime playback, since it needs to index the input file before you can retreive frames or audio samples. FFMS2 does not currently handle things like subtitles, file attachments or chapters. FFMS2's video frame and audio sample retrieval functions are not threadsafe; you may only have one request going at a time.
</p>


<h2>Compilation</h2>
<p>FFMS2 has the following dependencies:</p>
<ul>
<li><b><a href="http://www.ffmpeg.org">ffmpeg</a></b> (no, really)
<ul><li>Revision <del>18378 (2009-04-08) or later</del> something very fucking recent (usually latest SVN; in fact just use the latest SVN revision you can get to compile) is required.</li>
<li><a href="http://gitorious.org/ffmpeg/ffmpeg-mt">ffmpeg-mt</a> with pthreads may be used instead of vanilla ffmpeg.</li>
<li>Needs to have libpostproc compiled in (pass <tt>--enable-gpl --enable-postproc</tt> to ffmpeg's ./configure).</li>
<li>If you're on Win32 you need to pass <tt>--enable-memalign-hack</tt> to ffmpeg's ./configure as well.</li>
</ul>
</li>
<li><b><a href="http://www.zlib.net/">zlib</a></b></li>
</ul>
<p>
Compiling the library itself is fairly straightforward. For the basics, just add the <tt>include</tt> folder to your include paths and compile everything in <tt>src/core</tt>; everything else can be skipped. <tt>src/avisynth</tt> contains code for some Avisynth filters (optional and Windows-only); <tt>src/config</tt> is some MSVC-specific configuration; <tt>src/index</tt> is a stand-alone indexing application (built separately and linked against the main FFMS2 library); and <tt>src/test</tt> is an (incomplete) automatic regression test tool (also built separately). Take a look in <tt>doc/compiling.txt</tt> in the source tree for further details.
</p>
<h3>Windows-specific compilation notes</h3>
<p>
If you're compiling the library on Windows, it is suggested that you use the Microsoft Visual Studio 2008 solution file from SVN. Any version of MSVC2008 should work for compiling it, including the free Express Edition. The project file in question assumes that you have compiled ffmpeg with MinGW and want to link FFMS2 with it statically. Add your mingw/include and mingw/lib folders to MSVC's respective project directories and you should be good to go.
</p>
<p>
If you're using anything else, you're on your own. If you're building with some other version of MSVC that isn't 2008 you need to <tt>#define FFMS_EXPORTS</tt> somewhere when compiling the library. You may also <tt>#define HAALISOURCE</tt> if you want to make the library able to open MPEG TS/PS and OGM files using Haali's DirectShow splitter (if you do not define it, those files will be opened with libavformat instead, and that usually doesn't work out all that well). Note that if you do so, opening those files will fail unless the user has the <a href="http://haali.cs.msu.ru/mkv/">Haali Media Splitter</a> DirectShow filter installed.
</p>


<h2>Quickstart guide for impatient people</h2>
<p>
If you don't want to know anything about anything and just want to open some video with FFMS2 in the absolutely simplest possible manner, without selective indexing, progress reporting, saved index files, keyframe or timecode reading or anything like that, here's how to do it with the absolutely bare minimum of code.</p>

<pre>
#include &lt;ffms.h&gt;
#ifdef _WIN32
#include &lt;objbase.h&gt;
#endif

int main (...) {
	/* If you are on Windows you should first initialize COM, or all MPEG-TS/PS and OGM
	files may return an error when you try to open them (if the library was built
	with HAALISOURCE defined). All other formats will work normally. */
#ifdef _WIN32
	bool com_inited = false;
	HRESULT res = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (SUCCEEDED(res)) 
		com_inited = true;
	else if (res != RPC_E_CHANGED_MODE) {
		/* com initialization failed, handle error */
	}
#endif

	/* Initialize the library itself.
	You'll probably want to do the CPU caps detection automatically. */
	FFMS_Init(FFMS_CPU_CAPS_MMX | FFMS_CPU_CAPS_MMX2);

	/* Index the source file. Note that this example does not index any audio tracks. */
	char errmsg[1024];
	unsigned msgsize = sizeof(errmsg);
	const char *sourcefile = "somefilename";
	FFIndex *index = FFMS_MakeIndex(sourcefile, 0, 0, NULL, NULL, false, NULL, NULL, errmsg, msgsize);
	if (index == NULL) {
		/* handle error (print errmsg somewhere) */
	}

	/* Retrieve the track number of the first video track */
	int trackno = FFMS_GetFirstTrackOfType(index, FFMS_TYPE_VIDEO, errmsg, msgsize);
	if (trackno &lt; 0) {
		/* no video tracks found in the file, this is bad and you should handle it */
		/* (print the errmsg somewhere) */
	}

	/* We now have enough information to create the video source object */
	FFVideo *videosource = FFMS_CreateVideoSource(sourcefile, trackno, index, NULL, 1, FFMS_SEEK_NORMAL, errmsg, msgsize);
	if (videosource == NULL) {
		/* handle error (you should know what to do by now) */
	}

	/* Since the index is copied into the video source object upon its creation,
	we can and should now destroy the index object. */
	FFMS_DestroyIndex(index);

	/* Retrieve video properties so we know what we're getting.
	As the lack of the errmsg parameter indicates, this function cannot fail. */
	const FFVideoProperties *videoprops = FFMS_GetVideoProperties(videosource);

	/* 
	now you may want to do something with the info; particularly interesting values are:
	videoprops-&gt;Width; (frame width in pixels)
	videoprops-&gt;Height; (frame height in pixels)
	videoprops-&gt;NumFrames; (video length in number of frames)
	*/

	/* If you want to change the output colorspace or resize the output frame size,
	now is the time to do it. */
	/* See libavutil/pixfmt.h for the list of pixel formats/colorspaces.
	To get the name of a given pixel format, strip the leading PIX_FMT_
	and convert to lowercase. For example, PIX_FMT_YUV420P becomes "yuv420p". */
	int pixfmt = 1 &lt;&lt; FFMS_GetPixFmt("bgra");
	if (FFMS_SetOutputFormatV(videosource, (int64_t)pixfmt, videoprops-&gt;Width, videoprops-&gt;Height, errmsg, msgsize)) {
		/* handle error */
	}

	/* now we're ready to actually retrieve the video frames */
	int framenumber = 0; /* valid until next call to FFMS_GetFrame* on the same video object */
	const FFAVFrame *curframe = FFMS_GetFrame(videosource, framenumber, errmsg, msgsize);
	if (curframe = NULL) {
		/* handle error */
	}
	/* do something with curframe */
	/* continue doing this until you're bored, or something */

	/* now it's time to clean up */
	FFMS_DestroyVideoSource(videosource);
#ifdef _WIN32
	if (com_inited)
		CoUninitialize();
#endif
	
	exit 0;
}
</pre>

<p>
And that's pretty much it. Easy, ain't it?
</p>


<h2>Indexing and You</h2>
<p>
Before opening a media file with FFMS2, you <b>must</b> index it. This is to ensure that keyframe positions, timecode data and other interesting things are known so that frame-accurate seeking is easily possible. 
</p>
<p>
There are two ways to index a media file. The first one is really a backwards compatibility thing and uses <tt>FFMS_MakeIndex</tt>. You call the function with the source filename, a binary mask representing what audio tracks you want to index (all video tracks are always automatically indexed; you have no choice in the matter), another binary mask representing what audio tracks you want to dump to Wave64 files on disk, an optional progress reporting callback and a likewise optional audio dump filename generation callback; and it will create an index object. With this method there is no way of telling ahead of time how many tracks the file has and hence the only two masks that are useful in practice are 0 (index nothing) and -1 (index everything). If you want to index only certain tracks you will have to redo the indexing after examining the index. This indexing method may be used if you only want to index video tracks, or if you want all the audio tracks regardless of how many they are, or if you already know the track layout of the file you're going to open.
</p>
<p>
The other method is a bit more sophisticated. First, you create an indexer object using <tt>FFMS_CreateIndexer</tt> and the source filename. You can then examine the indexer using <tt>FFMS_GetNumTracksI</tt>, <tt>FFMS_GetTrackTypeI</tt> and <tt>FFMS_GetCodecNameI</tt> to determine how many tracks there are and what their respective types are. When you have done so, you call <tt>FFMS_DoIndexing</tt>, which is exactly like <tt>FFMS_MakeIndex</tt> except you pass it the indexer object instead of the source filename. Since you now know the track layout, you are free to pass a more restrictive track mask to index only the tracks relevant to your interests. As with <tt>FFMS_MakeIndex</tt>, all video tracks are always indexed; the trackmask only applies to audio tracks. If you change your mind and decide there are no tracks interesting to you in the file, call <tt>FFMS_CancelIndexing</tt>. Both <tt>FFMS_DoIndexing</tt> and <tt>FFMS_CancelIndexing</tt> destroys the indexer object and frees its memory.
</p>
<p>
When you have indexed the file you can write the index object to a disk file using <tt>FFMS_WriteIndex</tt>, which is useful if you expect to open the same file more than once, since it saves you from reindexing it every time. It can be particularly time-saving with very large files or files with a lot of audio tracks, since both of those can take quite some time to index.
</p>
<p>
To create an index object from a saved disk file, use <tt>FFMS_ReadIndex</tt>. Note that the index file written has an internal version number; if you have a version of FFMS2 that isn't the same as the one that created the index, it will most likely not accept the index at all (the read function will fail). If you want to verify that a given index file actually is an index of the source file you think it is, use <tt>FFMS_IndexBelongsToFile</tt>.
</p>


<h2>Function Reference</h2>
<p>Most functions that can fail in one way or another (as well as some that should be able to but currently don't) support error reporting using the <tt>ErrorMsg</tt> and <tt>MsgSize</tt> parameters. Example:</p>
<pre>char err[1024];
unsigned errsize = sizeof(err);

const FFAVFrame *frame = FFMS_GetFrame(vb, frameno, err, errsize);
/* failure? */
if (frame == NULL) {
	printf("failed to get frame number %d, error message: %s", frameno, err);
	/* etc... */
}</pre>
<p>
How many characters you want to allocate to the error message is up to you; if you allocate too few the messages may get truncated. 1024 should be enough for anyone.
</p>

<h3>FFMS_Init - initializes the library</h3>
<pre>void FFMS_Init(int CPUFeatures)</pre>
<p>Initializes the FFMS2 library. This function must be called once at the start of your program, before doing any other FFMS2 function calls. Its only argument is an integer representing what CPU instruction sets may be used by the parts of FFmpeg that have handwritten assembler (see <tt>FFMS_CPUFeatures</tt> in the Constants and Preprocessor Definitions section; binary OR the constants together if you want more than one). Pass NULL if you don't care; the performance hit won't be that big unless you do a lot of postprocessing or rescaling.</p>
<p>If you are on Windows, you should also initialize COM before calling this function, since the library might have been built with <tt>HAALISOURCE</tt>. If it was indeed built with <tt>HAALISOURCE</tt> but you do not intialize COM, all MPEG-TS/PS and OGM files will cause an error when you try to open them. All other file types will work normally. Typically, you'd initialize COM something like the following:</p>
<pre>#include &lt;objbase.h&gt;
/* later on, in the actual code... */
bool com_inited = false;
HRESULT res = CoInitializeEx(NULL, COINIT_MULTITHREADED);
if (SUCCEEDED(res)) 
	com_inited = true;
else if (res != RPC_E_CHANGED_MODE) {
	/* com initialization failed, handle error */
}
/* your code goes here */
/* and after you're done: */
if (com_inited)
	CoUninitialize();
</pre>

<h3>FFMS_GetLogLevel - gets ffmpeg message level</h3>
<pre>int FFMS_GetLogLevel()</pre>
<p>Retrieves ffmpeg's current logging/message level (i.e. how much diagnostic noise it prints to <tt>STDERR</tt>). If you want to make any sense of the returned value you'd better <tt>#include &lt;libavutil/log.h&gt;</tt> from the ffmpeg source tree to get the relevant constant definitions. Alternatively, just copy the relevant constant definitions into your own code and hope the ffmpeg devs doesn't change them randomly for no particular reason like they do with everything else.
</p>

<h3>FFMS_SetLogLevel - sets ffmpeg message level</h3>
<pre>void FFMS_SetLogLevel(int Level)</pre>
<p>Sets ffmpeg's logging/message level; see <tt>FFMS_GetLogLevel()</tt> for details.</p>

<h3>FFMS_CreateVideoSource - creates a video source object</h3>
<pre>FFVideo *FFMS_CreateVideoSource(const char *SourceFile, int Track, FFIndex *Index, const char *PP,
	int Threads, int SeekMode, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Creates a <tt>FFVideo</tt> object with the given properties. The <tt>FFVideo</tt> object represents a video stream, and can be passed to other functions to retreive frames and metadata from said stream. The video stream in question must be indexed first (see the indexing functions). Note that the index object is copied into the <tt>FFVideo</tt> object upon its creation, so once you've created the video source you can generally destroy the index object immediately, since all info you can retrieve from it is also retrievable from the <tt>FFVideo</tt> object.
</p>
<h4>Arguments</h4>
<p><b><tt>const char *SourceFile</tt></b><br />
The source file to open. Can be an absolute or relative path.</p>
<p><b><tt>int Track</tt></b><br />
The track number of the video track to open, as seen by the relevant demuxer. See <tt>FFMS_GetNumTracks</tt>, <tt>FFMS_GetTrackType</tt>, <tt>FFMS_GetFirstTrackOfType</tt> and their variants for further information on how to determine this.</p>
<p><b><tt>FFIndex *Index</tt></b><br />
A pointer to a FFIndex object containing indexing information for the track you want to open.</p>
<p><b><tt>const char *PP</tt></b><br />
A string describing the desired postprocessing. See the "PP string format" section below for details. Pass NULL or an empty string to disable postprocessing.</p>
<p><b><tt>int Threads</tt></b><br />
The number of decoding threads to use. Passing funny values like 0 or -1 may lead to undefined behavior so you better sanity check the input if you let the user set this. Values &gt;1 have no effect if ffmpeg was not compiled with threading support.</p>
<p><b><tt>int SeekMode</tt></b><br />
Controls how seeking (random access) is handled and hence affects frame accuracy. You will almost always want to use <tt>FFMS_SEEK_NORMAL</tt>. Has no effect on Matroska files, where the equivalent of <tt>FFMS_SEEK_NORMAL</tt> is always used. For a list of valid values, see the Constants and Preprocessor Definitions section.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns a pointer to the created <tt>FFVideo</tt> object on success. Returns <tt>NULL</tt> and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_CreateAudioSource - creates an audio source object</h3>
<pre>FFAudio *FFMS_CreateAudioSource(const char *SourceFile, int Track, FFIndex *Index,
	char *ErrorMsg, unsigned MsgSize)</pre>
<p>
Does exactly the same thing as <tt>FFMS_CreateVideoSource</tt>, but for audio tracks. Arguments and return values are identical. Do note that audio support is somewhat experimental and not guaranteed to be sample-accurate.
</p>

<h3>FFMS_DestroyVideoSource, FFMS_DestroyAudioSource - deallocates a video or audio source object</h3>
<pre>void FFMS_DestroyVideoSource(FFVideo *V)
void FFMS_DestroyAudioSource(FFAudio *A)</pre>
<p>
Deallocates the given <tt>FFVideo</tt> or <tt>FFAudio</tt> object and frees the memory allocated by <tt>FFMS_CreateVideoSource</tt> or <tt>FFMS_CreateAudioSource</tt>, respectively.
</p>

<h3>FFMS_GetVideoProperties - retrieves video properties</h3>
<pre>const FFVideoProperties *FFMS_GetVideoProperties(FFVideo *V)</pre>
<p>
Retreives the video properties from the given <tt>FFVideo</tt> object and stores them in a <tt>FFVideoProperties</tt> struct (see the Data Structures section below). Returns a pointer to said struct. Note that some of the properties (i.e. frame width/height and the pixel format) may be changed by calls to <tt>FFMS_SetOutputFormatV</tt> and <tt>FFMS_ResetOutputFormatV</tt>, so if you want to keep the video properties updated you'll need to call this function each time you've changed the output format.
</p>

<h3>FFMS_GetAudioProperties - retrieves audio properties</h3>
<pre>const FFAudioProperties *FFMS_GetAudioProperties(FFAudio *A)</pre>
<p>Does the exact same thing as <tt>FFMS_GetVideoProperties</tt>, but for an <tt>FFAudio</tt> object.
</p>

<h3>FFMS_GetFrame - retrieves a given video frame</h3>
<pre>const FFAVFrame *FFMS_GetFrame(FFVideo *V, int n, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Gets and decodes a video frame from the video stream represented by the given <tt>FFVideo</tt> object and stores it in a <tt>FFAVFrame</tt> struct. The colorspace and resolution of the frame can be changed by calling <tt>FFMS_SetOutputFormatV</tt> with the appropriate parameters before calling this function. Note that this function is not threadsafe; you can only request one frame at a time from a given <tt>FFVideo</tt> object.
</p>
<h4>Arguments</h4>
<p><b><tt>FFVideo *V</tt></b><br />
A pointer to the <tt>FFVideo</tt> object that represents the video stream you want to retrieve a frame from.</p>
<p><b><tt>int n</tt></b><br />
The frame number to get. Frame numbering starts from zero, and hence the first frame is number 0 (not 1) and the last frame is number <tt>FFVideoProperties->NumFrames</tt> minus 1. Requesting a frame number beyond the stream end or before the stream start (i.e. negative) may cause undefined behavior.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns a pointer to the <tt>AVFrameLite</tt> on success. Returns <tt>NULL</tt> and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_GetFrameByTime - retrieves a video frame at a given timestamp</h3>
<pre>const FFAVFrame *FFMS_GetFrameByTime(FFVideo *V, double Time, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Does the exact same thing as <tt>FFMS_GetFrame</tt> except instead of giving it a frame number you give it a timestamp in milliseconds, and it will retrieve the frame that starts closest to that timestamp. This function exists for the people who are too lazy to build and traverse a mapping between frame numbers and timestamps themselves.
</p>

<h3>FFMS_GetAudio - decodes a number of audio samples</h3>
<pre>int FFMS_GetAudio(FFAudio *A, void *Buf, int64_t Start, int64_t Count, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Decodes the requested audio samples from the audio stream represented by the given <tt>FFAudio</tt> object and stores them in the given buffer. Note that this function is not threadsafe; you can only request one decoding operation at a time from a given <tt>FFAudio</tt> object.
</p>
<h4>Arguments</h4>
<p><b><tt>FFAudio *A</tt></b><br />
A pointer to the <tt>FFAudio</tt> object that represents the audio stream you want to get samples from.</p>
<p><b><tt>void *Buf</tt></b><br />
A pointer to the buffer where the decoded samples will end up. You are responsible for allocating and freeing this buffer yourself, so you better check the <tt>FFAudioProperties</tt> for the sample format, number of channels, channel layout etc first, so you know how much memory you need to allocate.</p>
<p><b><tt>int64_t Start, int64_t Count</tt></b><br />
The range of samples you want decoded. The output is <tt>Count</tt> samples long, starting from <tt>Start</tt> (inclusive). Like video frame numbers, sample numbers start from zero and hence the last sample in the stream is number <tt>FFAudioProperties->NumSamples</tt> minus 1. Requesting samples beyond the stream end or before the stream start may result in undefined behavior.
</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns 0 on success. Returns non-0 and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_SetOutputFormatV - sets the output format for video frames</h3>
<pre>int FFMS_SetOutputFormatV(FFVideo *V, int64_t TargetFormats, int Width, int Height,
	char *ErrorMsg, unsigned MsgSize)</pre>
<p>Sets the colorspace and frame dimensions to be used for output of frames from the given <tt>FFVideo</tt> by all further calls to <tt>FFMS_GetFrame</tt> and <tt>FFMS_GetFrameByTime</tt>, until next time you call <tt>FFMS_SetOutputFormatV</tt> or <tt>FFMS_ResetOutputFormatV</tt>. You can change the output format at any time without having to reinitialize the <tt>FFVideo</tt> object or anything else. Can be used to convert the video to grayscale or monochrome if you are so inclined. If you provided a list of more than one colorspace/pixelformat, you may want to use <tt>FFMS_GetVideoProperties</tt> afterwards to see which one got selected.
</p>
<h4>Arguments</h4>
<p><b><tt>FFVideo *V</tt></b><br />
A pointer to the <tt>FFVideo</tt> object that represents the video stream you want to change the output format for.</p>
<p><b><tt>int64_t TargetFormats</tt></b><br />
The desired output colorspace(s). You may binary OR several colorspaces you are willing to accept together; the function will then choose the colorspace that gives the least lossy conversion from the source colorspace. To get the integer constant representing a given colorspace, see <tt>FFMS_GetPixFmt</tt>. Once you have the integer constant(s), shift 1 left by each constant to get the value suitable for passing as this argument. Example:<br /><tt>int64_t targetformats = (1 &lt;&lt; pixfmt1) | (1 &lt;&lt; pixfmt2) | (1 &lt;&lt; pixfmt3);</tt></p>
<p><b><tt>int Width, int Height</tt></b><br />
The desired image dimensions, in pixels. If you do not want to resize just pass the input dimensions. Passing invalid dimensions (like 0 or negative) has undefined behavior.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns 0 on success. Returns non-0 and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_ResetOutputFormatV - resets the video output format</h3>
<pre>void FFMS_ResetOutputFormatV(FFVideo *V)</pre>
<p>Resets the output format for the given <tt>FFVideo</tt> object so that no conversion takes place. Is a shorthand way of saying <tt>FFMS_SetOutputFormatV(V, FFVideoProperties->VPixelFormat, FFVideoProperties->Width, FFVideoProperties->Height, ErrorMsg, MsgSize)</tt>.
</p>

<h3>FFMS_DestroyFFIndex - deallocates an index object</h3>
<pre>void FFMS_DestroyFFIndex(FFIndex *Index)</pre>
<p>Deallocates the given <tt>FFIndex</tt> object and frees the memory that was allocated when it was created.
</p>

<h3>FFMS_GetFirstTrackOfType - gets the track number of the first track of a given type</h3>
<pre>int FFMS_GetFirstTrackOfType(FFIndex *Index, int TrackType, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Finds the first track of the given <tt>FFMS_TrackType</tt> in the given <tt>FFIndex</tt> and returns its track number, suitable for use as an argument to <tt>FFMS_CreateVideoSource</tt> or <tt>FFMS_CreateAudioSource</tt> as well as some other functions.
</p>
<h4>Arguments</h4>
<p><b><tt>FFIndex *Index</tt></b><br />
A pointer to the <tt>FFIndex</tt> object that represents the media file you want to look for tracks in.</p>
<p><b><tt>int TrackType</tt></b><br />
The track type to look for. See <tt>FFMS_TrackType</tt> in the Constants and Preprocessor Definitions" section for valid values.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns the track number (an integer greater than or equal to 0) on success. Returns a negative integer and sets ErrorMsg on failure (i.e. if no track of the given type was found).</p>

<h3>FFMS_GetFirstIndexedTrackOfType - gets the track number of the first track of a given type</h3>
<pre>int FFMS_GetFirstIndexedTrackOfType(FFIndex *Index, int TrackType, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Does the exact same thing as <tt>FFMS_GetFirstTrackOfType</tt> but ignores tracks that have not been indexed.
</p>

<h3>FFMS_GetNumTracks - gets the number of tracks in a given index</h3>
<pre>int FFMS_GetNumTracks(FFIndex *Index)</pre>
<p>Returns the total number of tracks in the media file represented by the given <tt>FFIndex</tt>.
</p>

<h3>FFMS_GetNumTracksI - gets the number of tracks in a given indexer</h3>
<pre>int FFMS_GetNumTracksI(FFIndexer *Indexer)</pre>
<p>Returns the total number of tracks in the media file represented by the given <tt>FFIndexer</tt>. In other words, does the same thing as <tt>FFMS_GetNumTracks</tt> but does not require indexing the entire file first.
</p>

<h3>FFMS_GetTrackType - gets the track type of a given track</h3>
<pre>int FFMS_GetTrackType(FFTrack *T)</pre>
<p>Returns an integer representing the <tt>FFMS_TrackType</tt> (see the Constants and Preprocessor Definitions section) of the track represented by the given <tt>FFTrack</tt> object.
</p>

<h3>FFMS_GetTrackTypeI - gets the track type of a given track</h3>
<pre>int FFMS_GetTrackTypeI(FFIndexer *Indexer, int Track)</pre>
<p>Returns an integer representing the <tt>FFMS_TrackType</tt> (see the Constants and Preprocessor Definitions section) of the track number <tt>Track</tt> in the media file represented by the given <tt>FFIndexer</tt>. In other words, does the same thing as <tt>FFMS_GetTrackType</tt>, but does not require having indexed the file first. If you have indexed the file, use <tt>FFMS_GetTrackType</tt> instead since the <tt>FFIndexer</tt> object is destructed when the index is created. Note that specifying an invalid track number may lead to undefined behavior.
</p>

<h3>FFMS_GetCodecNameI - gets the name of the codec used for a given track</h3>
<pre>const char *FFMS_GetCodecNameI(FFIndexer *Indexer, int Track)</pre>
<p>Returns the human-readable name ("long name" in ffmpeg terms) of the codec used in the given track number in the media file represented by the given <tt>FFIndexer</tt> object. Useful if you want to, say, pop up a menu asking the user which tracks he or she wishes to index. Note that specifying an invalid track number may lead to undefined behavior.
</p>

<h3>FFMS_GetNumFrames - gets the number of frames in a given track</h3>
<pre>int FFMS_GetNumFrames(FFTrack *T)</pre>
<p>Returns the number of frames in the track represented by the given <tt>FFTrack</tt>. For a video track this is the number of video frames, which can be useful; for an audio track it's the number of "packets", which is almost never useful. A return value of 0 indicates the track has not been indexed.
</p>

<h3>FFMS_GetFrameInfo - gets information about a given frame</h3>
<pre>const FFFrameInfo *FFMS_GetFrameInfo(FFTrack *T, int Frame)</pre>
<p>Gets information about the given frame (identified by its frame number) from the indexing information in the given <tt>FFTrack</tt> and stores it in a <tt>FFFrameInfo</tt> struct. See the Data Structures section below for more information. Using this function on a <tt>FFTrack</tt> representing a non-video track has undefined behavior.
</p>
<h4>Arguments</h4>
<p><b><tt>FFTrack *T</tt></b><br />
A pointer to the <tt>FFTrack</tt> object that represents the video track containing the frame you want to get information about.</p>
<p><b><tt>int Frame</tt></b><br />
The frame number to get information about. See <tt>FFMS_GetFrame</tt> for information about frame numbers. Requesting information about a frame before the start or after the end of the video track may result in undefined behavior, so don't do that.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns a pointer to the <tt>FFFrameInfo</tt> struct on success. Returns <tt>NULL</tt> and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_GetTrackFromIndex - retrieves track info from an index</h3>
<pre>FFTrack *FFMS_GetTrackFromIndex(FFIndex *Index, int Track)</pre>
<p>Gets track data for the given track number from the given <tt>FFIndex</tt> object, stores it in a <tt>FFTrack</tt> object and returns a pointer to it. Use this function if you don't want to (or cannot) open the track with <tt>FFMS_CreateVideoSource</tt> or <tt>FFMS_CreateAudioSource</tt> first. If you already have a <tt>FFVideo</tt> or <tt>FFAudio</tt> object it's safer to use <tt>FFMS_GetTrackFromVideo</tt> or <tt>FFMS_GetTrackFromAudio</tt> (see below) instead. Note that specifying a nonexistent or invalid track number leads to undefined behavior (usually an access violation). Also note that the returned <tt>FFTrack</tt> object is only valid until its parent <tt>FFIndex</tt> object is destroyed.
</p>
<h4>Arguments</h4>
<p><b><tt>FFIndex *Index</tt></b><br />
A pointer to the <tt>FFIndex</tt> object that represents the media file containing the track whose index information you want to get.</p>
<p><b><tt>int Track</tt></b><br />
The track number, as seen by the relevant demuxer (see <tt>FFMS_GetNumTracks</tt>, <tt>FFMS_GetTrackType</tt>, <tt>FFMS_GetFirstTrackOfType</tt> and their variants).</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns the <tt>FFTrack</tt> on success. Note that requesting indexing information for a track that has not been indexed will not cause an error, it will just return an empty <tt>FFTrack</tt> (check for >0 frames using <tt>FFMS_GetNumFrames</tt> to see if the returned object actually contains indexing information).</p>

<h3>FFMS_GetTrackFromVideo, FFMS_GetTrackFromAudio - retrieves track info from audio or video source</h3>
<pre>FFTrack *FFMS_GetTrackFromVideo(FFVideo *V)
FFTrack *FFMS_GetTrackFromAudio(FFAudio *A)</pre>
<p>Gets information about the track represented by the given <tt>FFVideo</tt> or <tt>FFAudio</tt> object and returns a pointer to a <tt>FFTrack</tt> object containing said information. It's generally safer to use these functions instead of <tt>FFMS_GetTrackFromIndex</tt>, since unlike that function they cannot cause random access violations, return a <tt>FFTrack</tt> that doesn't actually contain any indexing information, or return an object that ceases to be valid when the index is destroyed. Note that the returned <tt>FFTrack</tt> object is only valid until its parent <tt>FFVideo</tt> or <tt>FFAudio</tt> object is destroyed.
</p>

<h3>FFMS_GetTimeBase - retrieves the time base for the given track</h3>
<pre>const FFTrackTimeBase *FFMS_GetTimeBase(FFTrack *T)</pre>
<p>Finds the basic time unit for the track represented by the given <tt>FFTrack</tt>, stores it in a <tt>FFTrackTimeBase</tt> struct and returns a pointer to said struct. See the Data Structures section for information about the time base; note that it is only meaningful for video tracks.
</p>

<h3>FFMS_WriteTimecodes - writes timecodes for the given track to disk</h3>
<pre>int FFMS_WriteTimecodes(FFTrack *T, const char *TimecodeFile, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Writes Matroska v2 timecodes for the track represented by the given <tt>FFTrack</tt> to the given file. Only meaningful for video tracks.
</p>
<h4>Arguments</h4>
<p><b><tt>FFTrack *T</tt></b><br />
A pointer to the <tt>FFTrack</tt> object that represents the video track you want to write timecodes for.</p>
<p><b><tt>const char *TimecodeFile</tt></b><br />
The filename to write to. Can be a relative or absolute path. The file will be truncated and overwritten if it already exists.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Return values</h4>
<p>Returns 0 on success. Returns non-0 and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_MakeIndex - indexes a given source file</h3>
<pre>FFIndex *FFMS_MakeIndex(const char *SourceFile, int IndexMask, int DumpMask,
	TAudioNameCallback ANC, void *ANCPrivate, bool IgnoreDecodeErrors, TIndexCallback IC, void *ICPrivate,
	char *ErrorMsg, unsigned MsgSize)</pre>
<p>Indexes all video tracks and the given audio tracks in the given media file and returns a <tt>FFIndex</tt> object representing the file in question. Can also decode and write audio tracks to Wave64 files on disk while indexing.
</p>
<h4>Arguments</h4>
<p><b><tt>const char *SourceFile</tt></b><br />
The filename of the media file to index. Can be a relative or absolute path.</p>
<p><b><tt>int IndexMask, int DumpMask</tt></b><br />
Binary masks of the track numbers of the audio tracks to index and decode to disk, respectively. Pass 0 to index/decode no audio tracks, or -1 to index/decode all. Decoding a track means it will automatically be indexed regardless of what the <tt>IndexMask</tt> says, but indexing a track does not automatically mean that it will be decoded.</p>
<p><b><tt>TAudioNameCallback ANC</tt></b><br />
A function pointer to a callback function that will generate the filename(s) for the dumped audio tracks. To get the default filename(s), pass <tt>&amp;FFMS_DefaultAudioFilename</tt>. See <i>Callbacks</i> below for details if you want to write your own function. If the <tt>DumpMask</tt> is 0, you may pass NULL here.
</p>
<p><b><tt>void *ANCPrivate</tt></b><br />
A pointer of your choice that will be passed as an argument to the audio filename generation callback function. See <i>Callbacks</i> below for details. If <tt>DumpMask</tt> is 0, you may pass NULL here. If you are using <tt>FFMS_DefaultAudioFilename</tt>, you must pass a format string here. See the Audio Filename Format Strings section for details.
</p>
<p><b><tt>bool IgnoreDecodeErrors</tt></b><br />
If true, audio decoding errors will not cause indexing to fail. Tracks that cannot be decoded will not be indexed, however. Has no effect if the <tt>DumpMask</tt> is non-zero, in which case audio decoding errors will always cause the indexing to fail.</p>
<p><b><tt>TIndexCallback IC</tt></b><br />
A function pointer to a callback function that can be used to update progress. See <i>Callbacks</i> below for details.</p>
<p><b><tt>void *ICPrivate</tt></b><br />
A pointer of your choice that will be passed as an argument to the progress reporting callback function. See <i>Callbacks</i> below for details.</p>
<p><b><tt>char *ErrorMsg, unsigned MsgSize</tt></b><br />
See above.</p>
<h4>Callbacks</h4>
<p>This function has two potential callbacks. One can, if you so desire, call your code back intermittently so you can see how the indexing is progressing. This is accomplished using a function pointer to a function with the following signature:
</p>
<pre>int FFMS_CC FunctionName(int64_t Current, int64_t Total, void *ICPrivate)</pre>
<p> The callback function's arguments are as follows:</p>
<ul>
<li><tt><b>int64_t Current, int64_t Total</b></tt> - The indexing progress (amount done/total amount).</li>
<li><tt><b>void *Private</b></tt> - the same pointer as the one you passed as the <tt>Private</tt> argument to <tt>FFMS_MakeIndex</tt>. Can be used for anything you like, but one example (in a GUI program) is to use it for passing a progress ticker object that you can update with each call to the indexing function.</li>
</ul>
<p>Return 0 from the callback function to continue indexing, non-0 to cancel indexing (returning non-0 will make <tt>FFMS_MakeIndex</tt> fail with the reason "indexing cancelled by user").
</p>
<p>
The other callback is used to generate the filename(s) of the audio file(s) written if <tt>DumpMask</tt> is non-zero. It has the following signature:
</p>
<pre>int FFMS_CC FunctionName(const char *SourceFile, int Track, const FFAudioProperties *AP,
	char *FileName, int FNSize, void *Private)</pre>
<p>The callback function is called twice for each audio file generated. The first time <tt>FileName</tt> is NULL, and you should return the number of characters your generated filename will use plus one, and do nothing else. The second time <tt>FileName</tt> is a pointer to a pre-allocated array of char; you should write your generated filename to that and return the number of characters actually written plus one. Generally the easiest way to do this in both cases is to use <tt>snprintf</tt>. See the implementation of <tt>GenAudioFilename</tt> in ffmsindex.cpp for an example on how to do it.<br />
The callback function's arguments are as follows:</p>
<ul>
<li><tt><b>const char *SourceFile</b></tt> - The name of the source media file.</li>
<li><tt><b>int Track</b></tt> - The track number of the audio track being dumped.</li>
<li><tt><b>const FFAudioProperties *AP</b></tt> - A pointer to the <tt>FFAudioProperties</tt> struct containing information about the audio track being dumped. Note that the <tt>LastTime</tt> field is not defined since the last timestamp has not yet been encountered during indexing.</li>
<li><tt><b>char *FileName</b></tt> - A pointer to the string to which the callback function should write the generated filename (see above).</li>
<li><tt><b>int FNSize</b></tt> - The length of the <tt>FileName</tt> string.</li>
<li><tt><b>void *Private</b></tt> - The <tt>ANCPrivate</tt> pointer passed to <tt>FFMS_MakeIndex</tt>. Can be used to store data between calls, or to give audio tracks individual names that aren't just based on their properties.</li>
</ul>
<p>Most of the parameters may seem pointless since you don't need to use them, but they are passed so that you can easily generate a filename based on the audio track's properties if you want to.
</p>
<h4>Return values</h4>
<p>Returns a pointer to the created <tt>FFIndex</tt> on success. Returns <tt>NULL</tt> and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_DefaultAudioFilename - default callback for audio filename generation</h3>
<p>This function generates a default audio filename for use when dumping audio tracks to disk as Wave64 files during indexing. Its only use in the public API is as a default callback for <tt>FFMS_MakeIndex</tt> and <tt>FFMS_DoIndexing</tt>; you should never call it directly. See <tt>FFMS_MakeIndex</tt> for a description of its arguments.</p>

<h3>FFMS_CreateIndexer - creates an indexer object for the given file</h3>
<pre>FFIndexer *FFMS_CreateIndexer(const char *SourceFile, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Creates a <tt>FFIndexer</tt> object for the given <tt>SourceFile</tt> and returns a pointer to it. See Indexing and You for details on how to use the indexer.</p>
<h4>Return values</h4>
<p>Returns a pointer to the <tt>FFIndexer</tt> on success. Returns NULL and sets <tt>ErrorMsg</tt> on failure.</p>

<h3>FFMS_DoIndexing - indexes the file represented by an indexer object</h3>
<pre>FFIndex *FFMS_DoIndexing(FFIndexer *Indexer, int IndexMask, int DumpMask,
	TAudioNameCallback ANC, void *ANCPrivate, bool IgnoreDecodeErrors, TIndexCallback IC, void *ICPrivate,
	char *ErrorMsg, unsigned MsgSize)</pre>
<p>Does the exact same thing as <tt>FFMS_MakeIndex</tt>, but takes an indexer object instead of a source filename. Return values and arguments are identical to <tt>FFMS_MakeIndex</tt>; see that function for details. See the Indexing and You section for more details about indexing. Note that calling this function destroys the <tt>FFIndexer</tt> object and frees the memory allocated by <tt>FFMS_CreateIndexer</tt>.</p>

<h3>FFMS_CancelIndexing - destroys the given indexer object</h3>
<pre>void FFMS_CancelIndexing(FFIndexer *Indexer)</pre>
<p>Destroys the given <tt>FFIndexer</tt> object and frees the memory allocated by <tt>FFMS_CreateIndexer</tt>.</p>

<h3>FFMS_ReadIndex - reads an index file from disk</h3>
<pre>FFIndex *FFMS_ReadIndex(const char *IndexFile, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Attempts to read indexing information from the given <tt>IndexFile</tt>, which can be an absolute or relative path. Returns the <tt>FFIndex</tt> on success; returns <tt>NULL</tt> and sets <tt>ErrorMsg</tt> on failure.
</p>

<h3>FFMS_IndexBelongsToFile - check if a given index belongs to a given file</h3>
<pre>int FFMS_IndexBelongsToFile(FFIndex *Index, const char *SourceFile, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Makes a heuristic (but very reliable) guess about whether the given <tt>FFIndex</tt> is actually an index of the given <tt>SourceFile</tt> or not. Useful to determine if the index object you just read with <tt>FFMS_ReadIndex</tt> is actually relevant to your interests or not, since the only way to pair up index files with source files is by comparing their filenames, which isn't very reliable.
</p>
<h4>Arguments</h4>
<p><b><tt>FFIndex *Index</tt></b><br />
The index object to check.</p>
<p><b><tt>const char *SourceFile</tt></b><br />
The source file to verify the index against.</p>
<h4>Return values</h4>
<p>Returns 0 if the given index is determined to belong to the given file. Returns non-0 and sets <tt>ErrorMsg</tt> otherwise.</p>

<h3>FFMS_WriteIndex - writes an index object to disk</h3>
<pre>int FFMS_WriteIndex(const char *IndexFile, FFIndex *TrackIndices, char *ErrorMsg, unsigned MsgSize)</pre>
<p>Writes the indexing information from the given <tt>FFIndex</tt> to the given <tt>IndexFile</tt> (which can be an absolute or relative path; it will be truncated and overwritten if it already exists). Returns 0 on success; returns non-0 and sets <tt>ErrorMsg</tt> on failure.
</p>

<h3>FFMS_GetPixFmt - gets a colorspace identifier from a colorspace name</h3>
<pre>int FFMS_GetPixFmt(const char *Name)</pre>
<p>Translates a given colorspace/pixel format <tt>Name</tt> to an integer constant representing it, suitable for passing to <tt>FFMS_SetOutputFormatV</tt> (after some manipulation, see that function for details). This function exists so that you don't have to include a ffmpeg header file in every single program you ever write. For a list of colorspaces and their names, see <tt>libavutil/pixfmt.h</tt>. To get the name of a colorspace, strip the leading <tt>PIX_FMT_</tt> and convert the remainder to lowercase. For example, the name of <tt>PIX_FMT_YUV420P</tt> is <tt>yuv420p</tt>. It is strongly recommended to use this function instead of including pixfmt.h directly, since this function guarantees that you will always get the constant definitions from the version of ffmpeg that FFMS2 was linked against.
</p>
<h4>Arguments</h4>
<p><b><tt>const char *Name</tt></b><br />
The name of the desired colorspace/pixel format.</p>
<h4>Return values</h4>
<p>Returns the integer constant representing the given colorspace/pixel format on success. Returns the integer constant representing <tt>PIX_FMT_NONE</tt> (that is, -1) on failure (i.e. if no matching colorspace was found), but note that you can call <tt>FFMS_GetPixFmt("none")</tt> and get the same return value without it being a failed call, strictly speaking.</p>


<h2>Data Structures</h2>
<p>
The following public data structures may be of interest.
</p>

<h3>FFAVFrame</h3>
<pre>struct FFAVFrame {
    uint8_t *Data[4];
    int Linesize[4];
    uint8_t *Base[4];
    int KeyFrame;
    int PictType;
};</pre>
<p>A struct representing a video frame. The fields are:</p>
<ul>
<li><b><tt>uint8_t *Data[4]</tt></b> - An array of pointers to the picture planes (fields containing actual pixel data). Planar formats use more than one plane, for example YV12 uses one plane each for the Y, U and V data. Packed formats (such as the various RGB32 flavors) use only the first plane. If you want to determine if plane <tt>i</tt> contains data or not, check for <tt>FFAVFrame-&gt;Linesize[i] &gt; 0</tt>.</li>
<li><b><tt>int Linesize[4]</tt></b> - An array of integers representing the length of each scan line in each of the four picture planes, in bytes. In alternative terminology, this is the "pitch" of the plane. The total size in bytes of picture plane <tt>i</tt> is <tt>FFAVFrame-&gt;Linesize[i] * FFVideoProperties-&gt;Height</tt>.</li>
<li><b><tt>uint8_t *Base[4]</tt></b> - Heavy machinery, no user serviceable parts inside, keep out.</li>
<li><b><tt>int KeyFrame</tt></b> - Nonzero if the frame is a keyframe, 0 otherwise.</li>
<li><b><tt>int PictType</tt></b> - The coding type (I/B/P etc) of the compressed frame. See the various <tt>FF_X_TYPE</tt> constant definitions in <tt>libavcodec/avcodec.h</tt> if you want to know what integer represents what type.</li>
</ul>

<h3>FFTrackTimeBase</h3>
<pre>struct FFTrackTimeBase {
	int64_t Num;
	int64_t Den;
};</pre>
<p>
A struct representing the basic time unit of a track, as a rational number where <tt>Num</tt> is the numerator and <tt>Den</tt> is the denominator. Note that while this rational number may occasionally turn out to be equal to 1/framerate for some CFR video tracks, it really has no relation whatsoever with the video framerate and you should definitely not assume anything framerate-related based on it.
</p>

<h3>FFFrameInfo</h3>
<pre>struct FFFrameInfo {
	int64_t DTS;
	bool KeyFrame;
};</pre>
<p>A struct representing basic metadata about a given video frame. The fields are:</p>
<ul>
<li><b><tt>int64_t DTS</tt></b> - The decoding timestamp of the frame. To convert this to a timestamp in wallclock milliseconds, use the relation <tt>int64_t timestamp = (int64_t)((FFFrameInfo-&gt;DTS * FFTrackTimeBase-&gt;Num) / (double)FFTrackTimeBase-&gt;Den)</tt>.</li>
<li><b><tt>bool KeyFrame</tt></b> - True if the frame is a keyframe, false otherwise.</li>
</ul>

<h3>FFVideoProperties</h3>
<pre>struct FFVideoProperties {
	int Width;
	int Height;
	int FPSDenominator;
	int FPSNumerator;
	int NumFrames;
	int VPixelFormat;
	int SARNum;
	int SARDen;
	int CropTop;
	int CropBottom;
	int CropLeft;
	int CropRight;
	double FirstTime;
	double LastTime;
};</pre>
<p>A struct containing metadata about a video track. The fields are:</p>
<ul>
<li><b><tt>int Width; int Height;</tt></b> - The width and height in pixels of the video frames output by calls to <tt>FFMS_GetFrame</tt> and its variants, as set by <tt>FFMS_SetOutputFormatV</tt> and <tt>FFMS_ResetOutputFormatV</tt>.</li>
<li><b><tt>int FPSDenominator; int FPSNumerator;</tt></b> - The nominal framerate of the track, as a rational number. For Matroska files, this number is based on the average frame duration of all frames, while for everything else it's based on the duration of the first frame. While it might seem tempting to use these values to extrapolate wallclock timestamps for each frame, you really shouldn't do that since it makes your code unable to handle variable framerate properly. The ugly reality is that these values are pretty much only useful for informational purposes; they are only somewhat reliable for antiquated containers like AVI. Normally they should never be used for practical purposes; generate individual frame timestamps from <tt>FFFrameInfo-&gt;DTS</tt> instead.</li>
<li><b><tt>int NumFrames;</tt></b> - The number of frames in the video track.</li>
<li><b><tt>int VPixelFormat;</tt></b> - An integer constant representing the colorspace/pixel format of the video frames output by <tt>FFMS_GetFrame</tt> and its variants, as set by <tt>FFMS_SetOutputFormatV</tt> and <tt>FFMS_ResetOutputFormatV</tt>. See also <tt>FFMS_GetPixFmt</tt> and <tt>libavutil/pixfmt.h</tt>.</li>
<li><b><tt>int SARNum; int SARDen;</tt></b> - The sample aspect ratio of the video frames, as a rational number where <tt>SARNum</tt> is the numerator and <tt>SARDen</tt> is the denominator.</li>
<li><b><tt>int CropTop; int CropBottom; int CropLeft; int CropRight;</tt></b> - The number of pixels the video frame should be cropped in each direction before being displayed.</li>
<li><b><tt>double FirstTime; double LastTime;</tt></b> - The first and last timestamp of the stream respectively, in milliseconds. Useful if you want to know if the stream has a delay, or for quickly determining its length in seconds.</li>
</ul>

<h3>FFAudioProperties</h3>
<pre>struct FFAudioProperties {
	int SampleFormat;
	int SampleRate;
	int BitsPerSample;
	int Channels;
	int64_t ChannelLayout;
	int64_t NumSamples;
	double FirstTime;
	double LastTime;
};</pre>
<p>A struct containing metadata about an audio track. The fields are:</p>
<ul>
<li><b><tt>int SampleFormat</tt></b> - An integer that represents the audio sample format. See <tt>FFMS_SampleFormat</tt> in the Constants and Preprocessor Definitions section.</li>
<li><b><tt>int SampleRate</tt></b> - The audio samplerate, in samples per second.</li>
<li><b><tt>int BitsPerSample</tt></b> - The number of bits per audio sample. Note that this signifies the number of bits actually used, not the number of bits used to store each sample, and may hence be different from what the <tt>SampleFormat</tt> would imply.</li>
<li><b><tt>int Channels</tt></b> - The number of audio channels.</li>
<li><b><tt>int64_t ChannelLayout</tt></b> - The channel layout of the audio stream. Constructed by binary OR'ing the relevant integers from <tt>FFMS_AudioChannel</tt> together, which means that if the audio has the channel <tt>FFMS_CH_EXAMPLE</tt>, the operation <tt>(ChannelOrder &amp; FFMS_CH_EXAMPLE)</tt> will evaluate to true. The samples are interleaved in the order the channels are listed in the <tt>FFMS_AudioChannel</tt> enum; see that part of the Constants and Preprocessor Definitions sections for more details.</li>
<li><b><tt>int64_t NumSamples</tt></b> - The number of samples in the audio track.</li>
<li><b><tt>double FirstTime; double LastTime;</tt></b> - The first and last timestamp of the stream respectively, in milliseconds. Useful if you want to know if the stream has a delay, or for quickly determining its length in seconds.</li>
</ul>


<h2>Constants and Preprocessor Definitions</h2>
<p>The following constants and preprocessor definititions defined in ffms.h are suitable for public usage.</p>

<h3>FFMS_CPUFeatures</h3>
<pre>enum FFMS_CPUFeatures {
	FFMS_CPU_CAPS_MMX       = 0x01,
	FFMS_CPU_CAPS_MMX2      = 0x02,
	FFMS_CPU_CAPS_3DNOW     = 0x04,
	FFMS_CPU_CAPS_ALTIVEC   = 0x08,
	FFMS_CPU_CAPS_BFIN      = 0x10
};</pre>
<p>
Used in <tt>FFMS_Init</tt> to indicate CPU instruction set capabilities. Should be self explanatory. For a lot of applications you can probably get away with simply hardcoding in <tt>FFMS_CPU_CAPS_MMX | FFMS_CPU_CAPS_MMX2</tt> in the call to <tt>FFMS_Init</tt>.
</p>

<h3>FFMS_SeekMode</h3>
<pre>enum FFMS_SeekMode {
	FFMS_SEEK_LINEAR_NO_RW  = -1,
	FFMS_SEEK_LINEAR        = 0,
	FFMS_SEEK_NORMAL        = 1,
	FFMS_SEEK_UNSAFE        = 2,
	FFMS_SEEK_AGGRESSIVE    = 3
};</pre>
<p>Used in <tt>FFMS_CreateVideoSource</tt> to control the way seeking is handled. Explanation of the values:</p>
<ul>
<li><b><tt>FFMS_SEEK_LINEAR_NO_RW</tt></b> - Linear access without rewind; i.e. will throw an error if each successive requested frame number isn't bigger than the last one. Only intended for opening images but might work on well with some obscure video format.</li>
<li><b><tt>FFMS_SEEK_LINEAR</tt></b> - Linear access (i.e. if you request frame <tt>n</tt> without having requested frames 0 to <tt>n-1</tt> in order first, all frames from 0 to <tt>n</tt> will have to be decoded before <tt>n</tt> can be delivered). The definition of slow, but should make some formats "usable".</li>
<li><b><tt>FFMS_SEEK_NORMAL</tt></b> - Safe normal. Bases seeking decisions on the keyframe positions reported by libavformat.</li>
<li><b><tt>FFMS_SEEK_UNSAFE</tt></b> - Unsafe normal. Same as <tt>FFMS_SEEK_NORMAL</tt> but no error will be thrown if the exact destination has to be guessed.</li>
<li><b><tt>FFMS_SEEK_AGGRESSIVE</tt></b> - Aggressive. Seeks in the forward direction even if no closer keyframe is known to exist. Only useful for testing and containers where libavformat doesn't report keyframes properly.</li>
</ul>

<h3>FFMS_TrackType</h3>
<pre>enum FFMS_TrackType {
	FFMS_TYPE_UNKNOWN = -1,
	FFMS_TYPE_VIDEO,
	FFMS_TYPE_AUDIO,
	FFMS_TYPE_DATA,
	FFMS_TYPE_SUBTITLE,
	FFMS_TYPE_ATTACHMENT
};</pre>
<p>
Used for determining the type of a given track. Note that there are currently no functions to handle any type of track other than <tt>FFMS_TYPE_VIDEO</tt> and <tt>FFMS_TYPE_AUDIO</tt>. See <tt>FFMS_GetTrackType</tt>, <tt>FFMS_GetFirstTrackOfType</tt> and their variants.
</p>

<h3>FFMS_SampleFormat</h3>
<pre>enum FFMS_SampleFormat {
    FFMS_FMT_U8 = 0,
    FFMS_FMT_S16,
    FFMS_FMT_S32,
    FFMS_FMT_FLT,
    FFMS_FMT_DBL
};</pre>
<p>Identifies various audio sample formats.</p>
<ul>
<li><b><tt>FFMS_FMT_U8</tt></b> - One 8-bit unsigned integer (<tt>uint8_t</tt>) per sample.</li>
<li><b><tt>FFMS_FMT_S16</tt></b> - One 16-bit signed integer (<tt>int16_t</tt>) per sample.</li>
<li><b><tt>FFMS_FMT_S32</tt></b> - One 32-bit signed integer (<tt>int32_t</tt>) per sample.</li>
<li><b><tt>FFMS_FMT_FLT</tt></b> - One 32-bit (single precision) floating point value (<tt>float_t</tt>) per sample.</li>
<li><b><tt>FFMS_FMT_DBL</tt></b> - One 64-bit (double precision) floating point value (<tt>double_t</tt>) per sample.</li>
</ul>

<h3>FFMS_AudioChannel</h3>
<pre>enum FFMS_AudioChannel {
	FFMS_CH_FRONT_LEFT              = 0x00000001,
	FFMS_CH_FRONT_RIGHT             = 0x00000002,
	FFMS_CH_FRONT_CENTER            = 0x00000004,
	FFMS_CH_LOW_FREQUENCY           = 0x00000008,
	FFMS_CH_BACK_LEFT               = 0x00000010,
	FFMS_CH_BACK_RIGHT              = 0x00000020,
	FFMS_CH_FRONT_LEFT_OF_CENTER    = 0x00000040,
	FFMS_CH_FRONT_RIGHT_OF_CENTER   = 0x00000080,
	FFMS_CH_BACK_CENTER             = 0x00000100,
	FFMS_CH_SIDE_LEFT               = 0x00000200,
	FFMS_CH_SIDE_RIGHT              = 0x00000400,
	FFMS_CH_TOP_CENTER              = 0x00000800,
	FFMS_CH_TOP_FRONT_LEFT          = 0x00001000,
	FFMS_CH_TOP_FRONT_CENTER        = 0x00002000,
	FFMS_CH_TOP_FRONT_RIGHT         = 0x00004000,
	FFMS_CH_TOP_BACK_LEFT           = 0x00008000,
	FFMS_CH_TOP_BACK_CENTER         = 0x00010000,
	FFMS_CH_TOP_BACK_RIGHT          = 0x00020000,
	FFMS_CH_STEREO_LEFT             = 0x20000000,
	FFMS_CH_STEREO_RIGHT            = 0x40000000
};</pre>
<p>
Describes various audio channel configurations. The names should be self-explanatory. The audio samples are interleaved in the order these channels are listed in; i.e. in the stereo case the left channel (<tt>FFMS_CH_FRONT_LEFT</tt>) comes first. Note that <tt>FFMS_CH_STEREO_LEFT</tt> and <tt>FFMS_CH_STEREO_RIGHT</tt> are <b>not</b> commonly used (see ffmpeg docs for a description of what exactly they are used for). For normal stereo audio <tt>FFMS_CH_FRONT_LEFT</tt> and <tt>FFMS_CH_FRONT_RIGHT_</tt> are used.
</p>


<h3>FFMS_CC</h3>
<pre>#ifdef _WIN32
#	define FFMS_CC __stdcall
#else
#	define FFMS_CC
#endif
</pre>
<p>
The calling convention used by FFMS2 API functions and callbacks. Defined to <tt>__stdcall</tt> if <tt>_WIN32</tt> is defined. Otherwise defined, but not used.
</p>


<h2>Audio Filename Format Strings</h2>
<p>The following variables can be used:</p>
<ul>
<li><tt>%sourcefile%</tt> - same as the source file name, i.e. the file the audio is decoded from</li>
<li><tt>%trackn%</tt> - the track number</li>
<li><tt>%trackzn%</tt> - the track number zero padded to 2 digits</li>
<li><tt>%samplerate%</tt> - the audio sample rate</li>
<li><tt>%channels%</tt> - number of audio channels</li>
<li><tt>%bps%</tt> - bits per sample</li>
<li><tt>%delay%</tt> - delay, or more exactly the first timestamp encountered in the audio stream</li>
</ul>
<p>
Example string: <tt>%sourcefile%_track%trackzn%.w64</tt>
</p>


<h2>PP string format</h2>
<pre>
Available postprocessing filters:
Filters                        Options
short  long name       short   long option     Description
*      *               a       autoq           CPU power dependent enabler
                       c       chrom           chrominance filtering enabled
                       y       nochrom         chrominance filtering disabled
                       n       noluma          luma filtering disabled
hb     hdeblock        (2 threshold)           horizontal deblocking filter
       1. difference factor: default=32, higher -&gt; more deblocking
       2. flatness threshold: default=39, lower -&gt; more deblocking
                       the h &amp; v deblocking filters share these
                       so you can't set different thresholds for h / v
vb     vdeblock        (2 threshold)           vertical deblocking filter
ha     hadeblock       (2 threshold)           horizontal deblocking filter
va     vadeblock       (2 threshold)           vertical deblocking filter
h1     x1hdeblock                              experimental h deblock filter 1
v1     x1vdeblock                              experimental v deblock filter 1
dr     dering                                  deringing filter
al     autolevels                              automatic brightness / contrast
f      fullyrange                              stretch luminance to (0..255)
lb     linblenddeint                           linear blend deinterlacer
li     linipoldeint                            linear interpolating deinterlace
ci     cubicipoldeint                          cubic interpolating deinterlacer
md     mediandeint                             median deinterlacer
fd     ffmpegdeint                             ffmpeg deinterlacer
l5     lowpass5                                FIR lowpass deinterlacer
de     default                                 hb:a,vb:a,dr:a
fa     fast                                    h1:a,v1:a,dr:a
ac                                             ha:a:128:7,va:a,dr:a
tn     tmpnoise        (3 threshold)           temporal noise reducer
                     1. &lt;= 2. &lt;= 3.            larger -&gt; stronger filtering
fq     forceQuant      &lt;quantizer&gt;             force quantizer
Usage:
&lt;filterName&gt;[:&lt;option&gt;[:&lt;option&gt;...]][[,|/][-]&lt;filterName&gt;[:&lt;option&gt;...]]...
long form example:
vdeblock:autoq/hdeblock:autoq/linblenddeint    default,-vdeblock
short form example:
vb:a/hb:a/lb                                   de,-vb
more examples:
tn:64:128:256
</pre>

</div>

</body>
</html>
